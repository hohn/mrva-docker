* Using the Containers
** Running the containers
   1. Start the containers
     #+BEGIN_SRC sh 
       cd ~/work-gh/mrva/mrva-docker/
       docker-compose -f docker-compose-demo.yml down
       docker ps
       docker-compose -f docker-compose-demo.yml up -d 
     #+END_SRC
   2. View all logs
      : docker-compose logs
   3. Follow all logs if started with =-d=
      #+BEGIN_SRC sh 
        docker-compose logs -f
      #+END_SRC

   4. Follow single container, =server=, logging via
      #+BEGIN_SRC sh 
        cd ~/work-gh/mrva/mrvacommander
        docker-compose up -d
        docker-compose logs -f server
      #+END_SRC
   5. Cleanup in case of obscure errors (network or other)
      #+BEGIN_SRC sh 
        docker-compose -f docker-compose-demo.yml down --volumes --remove-orphans
        docker network prune
        docker-compose -f docker-compose-demo.yml up --build
      #+END_SRC

** Use gh-mrva container to send request via cli
     #+BEGIN_SRC sh 
       # %% Start container and check gh-mrva tool
       # Start an interactive bash shell inside the running Docker container
       docker exec -it mrva-docker-client-ghmrva-1 bash

       # Check if the gh-mrva tool is installed and accessible
       gh-mrva -h

       # %% Set up gh-mrva configuration
       # Create configuration directory and generate config file for gh-mrva
       mkdir -p ~/.config/gh-mrva
       cat > ~/.config/gh-mrva/config.yml <<eof
       # Configuration file for the gh-mrva tool
       # codeql_path: Path to the CodeQL distribution (not used in this setup)
       # controller: Placeholder for a controller NWO (not relevant in this setup)
       # list_file: Path to the repository selection JSON file

       codeql_path: not-used/codeql-path
       controller: not-used/mirva-controller
       list_file: $HOME/work-gh/mrva/gh-mrva/gh-mrva-selection.json
       eof

       # %% Create repository selection list
       # Create a directory and generate the JSON file specifying repositories
       mkdir -p ~/work-gh/mrva/gh-mrva
       cat > ~/work-gh/mrva/gh-mrva/gh-mrva-selection.json <<eof
       {
           "mirva-list": [
               "Mbed-TLS/mbedtlsctsj17ef85",
               "ampl/gslctsj4b270e",
               "baidu/sofa-pbrpcctsjba3501",
               "dlundquist/sniproxyctsj3d83e7",
               "emscripten-core/emscriptenctsj16e1d3",
               "hyprwm/Hyprlandctsjc2425f",
               "lz4/lz4ctsj2479c5",
               "medooze/media-server-nodectsj5e30b3",
               "murat-dogan/node-datachannelctsj4edeef",
               "pmneila/PyMCubesctsj582da6",
               "tsl0922/ttydctsj2e3faa"
           ]
       }
       eof

       # %% Create and submit the first query (FlatBuffersFunc.ql)
       # Generate a sample CodeQL query for functions of interest
       cat > ~/work-gh/mrva/gh-mrva/FlatBuffersFunc.ql <<eof
       /**
        ,* @name pickfun
        ,* @description Pick function from FlatBuffers
        ,* @kind problem
        ,* @id cpp-flatbuffer-func
        ,* @problem.severity warning
        ,*/

       import cpp

       from Function f
       where
         f.getName() = "MakeBinaryRegion" or
         f.getName() = "microprotocols_add"
       select f, "definition of MakeBinaryRegion"
       eof

       # Submit the MRVA job with the first query
       cd ~/work-gh/mrva/gh-mrva/
       gh-mrva submit --language cpp --session mirva-session-1160 \
                 --list mirva-list                                \
                 --query ~/work-gh/mrva/gh-mrva/FlatBuffersFunc.ql

       # %% Check status and download results for the first session
       # Check the status of the submitted session
       gh-mrva status --session mirva-session-1160

       # Download SARIF files and databases if there are results.  For the current
       # query / database combination there are zero result hence no downloads
       cd ~/work-gh/mrva/gh-mrva/
       gh-mrva download --session mirva-session-1160   \
               --download-dbs                          \
               --output-dir mirva-session-1160

       # %% Next, run a query with results

       # %% Set up QLPack for the next query
       # Create a qlpack.yml file required for the next query
       cat > ~/work-gh/mrva/gh-mrva/qlpack.yml <<eof
       library: false
       name: codeql-dataflow-ii-cpp
       version: 0.0.1
       dependencies:
         codeql/cpp-all: 0.5.3
       eof

       # %% Create and submit the second query (Fprintf.ql)
       # Generate a CodeQL query to find calls to fprintf
       cat > ~/work-gh/mrva/gh-mrva/Fprintf.ql <<eof
       /**
        ,* @name findPrintf
        ,* @description Find calls to plain fprintf
        ,* @kind problem
        ,* @id cpp-fprintf-call
        ,* @problem.severity warning
        ,*/

       import cpp

       from FunctionCall fc
       where
         fc.getTarget().getName() = "fprintf"
       select fc, "call of fprintf"
       eof

       # Submit a new MRVA job with the second query
       cd ~/work-gh/mrva/gh-mrva/
       gh-mrva submit --language cpp --session mirva-session-1260 \
                 --list mirva-list                                \
                 --query ~/work-gh/mrva/gh-mrva/Fprintf.ql

       # %% Check status and download results for the second session
       # Check the status of the second session
       gh-mrva status --session mirva-session-1260

       # Download SARIF files and databases for the second query
       cd ~/work-gh/mrva/gh-mrva/
       gh-mrva download --session mirva-session-1260   \
               --download-dbs                          \
               --output-dir mirva-session-1260
     #+END_SRC
** Send request via gui, using vs code
   The following sequence works when run from a local vs code with the custom
   codeql plugin.

   1. =ql tab > variant analysis repositories > {}=, put this into
      =databases.json=
      #+begin_src javascript
        {
            "version": 1,
            "databases": {
                "variantAnalysis": {
                    "repositoryLists": [
                        {
                            "name": "mirva-list",
                            "repositories": [
                                "lz4/lz4ctsj2479c5",
                                "pmneila/PyMCubesctsj582da6",
                                "murat-dogan/node-datachannelctsj4edeef",
                                "Mbed-TLS/mbedtlsctsj17ef85",
                                "tsl0922/ttydctsj2e3faa",
                                "medooze/media-server-nodectsj5e30b3",
                                "ampl/gslctsj4b270e",
                                "baidu/sofa-pbrpcctsjba3501",
                                "emscripten-core/emscriptenctsj16e1d3",
                                "dlundquist/sniproxyctsj3d83e7",
                                "hyprwm/Hyprlandctsjc2425f"
                            ]
                        }
                    ],
                    "owners": [],
                    "repositories": []
                }
            },
            "selected": {
                "kind": "variantAnalysisUserDefinedList",
                "listName": "mirva-list"
            }
        }
      #+end_src

   2. =ql tab > variant analysis repositories > select mrva-list=

   3. select file =qldemo/simple.ql= and put =Fprintf.ql= parallel to it:
      #+BEGIN_SRC java
        /**
         ,* @name findPrintf
         ,* @description find calls to plain fprintf
         ,* @kind problem
         ,* @id cpp-fprintf-call
         ,* @problem.severity warning
         ,*/

        import cpp

        from FunctionCall fc
        where
          fc.getTarget().getName() = "fprintf"
        select fc, "call of fprintf"
      #+END_SRC

   4. Adjust the qlpack.yml to cpp, from python.
   5. Submit the analysis job. 
